import VASSAL.tools.concurrent.listener
import java.lang
import java.util
import java.util.concurrent
import java.util.concurrent.locks
import typing



_ConcurrentSoftHashMap__SimpleEntry__K = typing.TypeVar('_ConcurrentSoftHashMap__SimpleEntry__K')  # <K>
_ConcurrentSoftHashMap__SimpleEntry__V = typing.TypeVar('_ConcurrentSoftHashMap__SimpleEntry__V')  # <V>
_ConcurrentSoftHashMap__K = typing.TypeVar('_ConcurrentSoftHashMap__K')  # <K>
_ConcurrentSoftHashMap__V = typing.TypeVar('_ConcurrentSoftHashMap__V')  # <V>
class ConcurrentSoftHashMap(java.util.AbstractMap[_ConcurrentSoftHashMap__K, _ConcurrentSoftHashMap__V], java.util.concurrent.ConcurrentMap[_ConcurrentSoftHashMap__K, _ConcurrentSoftHashMap__V], typing.Generic[_ConcurrentSoftHashMap__K, _ConcurrentSoftHashMap__V]):
    def __init__(self): ...
    def clear(self) -> None: ...
    def containsKey(self, object: typing.Any) -> bool: ...
    def entrySet(self) -> java.util.Set[java.util.Map.Entry[_ConcurrentSoftHashMap__K, _ConcurrentSoftHashMap__V]]: ...
    def get(self, object: typing.Any) -> _ConcurrentSoftHashMap__V: ...
    def put(self, k: _ConcurrentSoftHashMap__K, v: _ConcurrentSoftHashMap__V) -> _ConcurrentSoftHashMap__V: ...
    def putIfAbsent(self, k: _ConcurrentSoftHashMap__K, v: _ConcurrentSoftHashMap__V) -> _ConcurrentSoftHashMap__V: ...
    @typing.overload
    def remove(self, object: typing.Any, object2: typing.Any) -> bool: ...
    @typing.overload
    def remove(self, object: typing.Any) -> _ConcurrentSoftHashMap__V: ...
    @typing.overload
    def replace(self, k: _ConcurrentSoftHashMap__K, v: _ConcurrentSoftHashMap__V, v2: _ConcurrentSoftHashMap__V) -> bool: ...
    @typing.overload
    def replace(self, k: _ConcurrentSoftHashMap__K, v: _ConcurrentSoftHashMap__V) -> _ConcurrentSoftHashMap__V: ...
    def size(self) -> int: ...
    class SimpleEntry(java.util.Map.Entry[_ConcurrentSoftHashMap__SimpleEntry__K, _ConcurrentSoftHashMap__SimpleEntry__V], typing.Generic[_ConcurrentSoftHashMap__SimpleEntry__K, _ConcurrentSoftHashMap__SimpleEntry__V]):
        @typing.overload
        def __init__(self, k: _ConcurrentSoftHashMap__SimpleEntry__K, v: _ConcurrentSoftHashMap__SimpleEntry__V): ...
        @typing.overload
        def __init__(self, entry: java.util.Map.Entry[_ConcurrentSoftHashMap__SimpleEntry__K, _ConcurrentSoftHashMap__SimpleEntry__V]): ...
        def equals(self, object: typing.Any) -> bool: ...
        def getKey(self) -> _ConcurrentSoftHashMap__SimpleEntry__K: ...
        def getValue(self) -> _ConcurrentSoftHashMap__SimpleEntry__V: ...
        def hashCode(self) -> int: ...
        def setValue(self, v: _ConcurrentSoftHashMap__SimpleEntry__V) -> _ConcurrentSoftHashMap__SimpleEntry__V: ...
        def toString(self) -> str: ...

class CountingReadWriteLock(java.util.concurrent.locks.ReadWriteLock):
    def __init__(self): ...
    def readLock(self) -> java.util.concurrent.locks.Lock: ...
    def writeLock(self) -> java.util.concurrent.locks.Lock: ...

class DaemonThreadFactory(java.util.concurrent.ThreadFactory):
    def __init__(self, string: str): ...
    def newThread(self, runnable: typing.Union[java.lang.Runnable, typing.Callable]) -> java.lang.Thread: ...

class Exec:
    ex: typing.ClassVar[java.util.concurrent.ExecutorService] = ...

class FutureUtils:
    @typing.overload
    def wait(self, long: int) -> None: ...
    @typing.overload
    def wait(self) -> None: ...
    @typing.overload
    def wait(self, long: int, int: int) -> None: ...
    @typing.overload
    @staticmethod
    def wait(future: java.util.concurrent.Future[typing.Any]) -> None: ...

class QueueJoiner(java.util.concurrent.Callable[None]):
    def __init__(self, blockingQueue: java.util.concurrent.BlockingQueue[java.util.concurrent.Callable[typing.Any]]): ...
    def call(self) -> None: ...

_RangedRunnable__T = typing.TypeVar('_RangedRunnable__T')  # <T>
class RangedRunnable(java.lang.Runnable, typing.Generic[_RangedRunnable__T]):
    def __init__(self, t: _RangedRunnable__T): ...
    def run(self) -> None: ...
    def setLast(self, t: _RangedRunnable__T, boolean: bool) -> None: ...

_SettableFuture__V = typing.TypeVar('_SettableFuture__V')  # <V>
class SettableFuture(java.util.concurrent.Future[_SettableFuture__V], typing.Generic[_SettableFuture__V]):
    def set(self, v: _SettableFuture__V) -> None: ...
    def setException(self, throwable: java.lang.Throwable) -> None: ...

_SettableRunnableFuture__V = typing.TypeVar('_SettableRunnableFuture__V')  # <V>
class SettableRunnableFuture(SettableFuture[_SettableRunnableFuture__V], java.util.concurrent.RunnableFuture[_SettableRunnableFuture__V], typing.Generic[_SettableRunnableFuture__V]): ...

_SimpleFuture__V = typing.TypeVar('_SimpleFuture__V')  # <V>
class SimpleFuture(SettableFuture[_SimpleFuture__V], typing.Generic[_SimpleFuture__V]):
    def __init__(self): ...
    def cancel(self, boolean: bool) -> bool: ...
    @typing.overload
    def get(self) -> _SimpleFuture__V: ...
    @typing.overload
    def get(self, long: int, timeUnit: java.util.concurrent.TimeUnit) -> _SimpleFuture__V: ...
    def isCancelled(self) -> bool: ...
    def isDone(self) -> bool: ...
    def set(self, v: _SimpleFuture__V) -> None: ...
    def setException(self, throwable: java.lang.Throwable) -> None: ...

_SimpleRunnableFuture__V = typing.TypeVar('_SimpleRunnableFuture__V')  # <V>
class SimpleRunnableFuture(SimpleFuture[_SimpleRunnableFuture__V], SettableRunnableFuture[_SimpleRunnableFuture__V], typing.Generic[_SimpleRunnableFuture__V]):
    def __init__(self): ...


class __module_protocol__(typing.Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("VASSAL.tools.concurrent")``.

    ConcurrentSoftHashMap: typing.Type[ConcurrentSoftHashMap]
    CountingReadWriteLock: typing.Type[CountingReadWriteLock]
    DaemonThreadFactory: typing.Type[DaemonThreadFactory]
    Exec: typing.Type[Exec]
    FutureUtils: typing.Type[FutureUtils]
    QueueJoiner: typing.Type[QueueJoiner]
    RangedRunnable: typing.Type[RangedRunnable]
    SettableFuture: typing.Type[SettableFuture]
    SettableRunnableFuture: typing.Type[SettableRunnableFuture]
    SimpleFuture: typing.Type[SimpleFuture]
    SimpleRunnableFuture: typing.Type[SimpleRunnableFuture]
    listener: VASSAL.tools.concurrent.listener.__module_protocol__
